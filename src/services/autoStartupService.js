/**
 * Auto Startup Service for Iranian Legal Archive
 * Automatically initializes all services when page loads
 */

import SmartProxyService from './smartProxyService.js';
import AdvancedScrapingService from './advancedScrapingService.js';
import diagnostics from '../utils/diagnostics.js';

class AutoStartupService {
  constructor() {
    this.isInitialized = false;
    this.services = {};
    this.startupLog = [];
    this.persistenceKey = 'iranianLegalArchive_state';
    
    // Service configuration
    this.serviceConfig = {
      proxyService: { enabled: true, priority: 1 },
      scrapingService: { enabled: true, priority: 2 },
      backgroundTasks: { enabled: true, priority: 3 },
      dataSync: { enabled: true, priority: 4 }
    };
    
    this.log('üöÄ AutoStartupService initialized');
  }

  /**
   * Enhanced logging with diagnostics integration
   */
  log(message, level = 'info') {
    const timestamp = new Date().toISOString();
    const logEntry = { timestamp, message, level };
    this.startupLog.push(logEntry);
    
    // Enhanced console logging with colors and emojis
    const prefix = `[AutoStartup ${timestamp.split('T')[1].split('.')[0]}]`;
    
    switch (level) {
      case 'error':
        console.error(`‚ùå ${prefix} ${message}`);
        break;
      case 'warn':
        console.warn(`‚ö†Ô∏è ${prefix} ${message}`);
        break;
      case 'success':
        console.log(`‚úÖ ${prefix} ${message}`);
        break;
      case 'debug':
        console.debug(`üîç ${prefix} ${message}`);
        break;
      default:
        console.log(`‚ÑπÔ∏è ${prefix} ${message}`);
    }
    
    // Store in global diagnostic logs
    if (!window.diagnosticConsoleLogs) {
      window.diagnosticConsoleLogs = [];
    }
    window.diagnosticConsoleLogs.push(logEntry);
    
    // Keep only last 100 logs
    if (window.diagnosticConsoleLogs.length > 100) {
      window.diagnosticConsoleLogs = window.diagnosticConsoleLogs.slice(-100);
    }
    
    // Persist logs
    this.saveState();
  }

  /**
   * Load previous state from localStorage
   */
  loadState() {
    try {
      const saved = localStorage.getItem(this.persistenceKey);
      if (saved) {
        const state = JSON.parse(saved);
        this.log(`üìÇ Loaded previous state: ${Object.keys(state).length} items`);
        return state;
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Error loading state: ${error.message}`);
    }
    return {};
  }

  /**
   * Save current state to localStorage
   */
  saveState() {
    try {
      const state = {
        isInitialized: this.isInitialized,
        startupLog: this.startupLog.slice(-50), // Keep last 50 logs
        services: Object.keys(this.services),
        lastUpdate: new Date().toISOString(),
        sessionId: this.getSessionId()
      };
      
      localStorage.setItem(this.persistenceKey, JSON.stringify(state));
    } catch (error) {
      console.warn('Failed to save state:', error);
    }
  }

  /**
   * Get or create session ID
   */
  getSessionId() {
    let sessionId = sessionStorage.getItem('sessionId');
    if (!sessionId) {
      sessionId = Date.now().toString(36) + Math.random().toString(36).substr(2);
      sessionStorage.setItem('sessionId', sessionId);
    }
    return sessionId;
  }

  /**
   * Initialize all services automatically
   */
  async autoInitialize() {
    if (this.isInitialized) {
      this.log('‚úÖ System already initialized');
      this.setGlobalReadyState();
      return this.getSystemStatus();
    }

    this.log('üîÑ Starting auto-initialization...');
    
    try {
      // Run initial diagnostics
      this.log('üîç Running pre-initialization diagnostics...', 'debug');
      const preDiagnostics = await diagnostics.runDiagnostics();
      this.log(`üìä Environment: ${preDiagnostics.systemState.environment}`, 'info');
      
      // Step 1: Initialize Smart Proxy Service
      this.log('üåê Step 1/5: Initializing Smart Proxy Service...', 'info');
      await this.initializeProxyService();
      
      // Step 2: Initialize Scraping Service  
      this.log('üîç Step 2/5: Initializing Scraping Service...', 'info');
      await this.initializeScrapingService();
      
      // Step 3: Setup Background Tasks
      this.log('‚öôÔ∏è Step 3/5: Setting up Background Tasks...', 'info');
      await this.setupBackgroundTasks();
      
      // Step 4: Initialize Data Persistence
      this.log('üíæ Step 4/5: Initializing Data Persistence...', 'info');
      await this.initializeDataPersistence();
      
      // Step 5: Setup Auto-Update
      this.log('üîÑ Step 5/5: Setting up Auto-Update...', 'info');
      await this.setupAutoUpdate();
      
      this.isInitialized = true;
      this.log('üéâ Auto-initialization completed successfully!', 'success');
      
      // Set global ready state for React app
      this.setGlobalReadyState();
      
      // Dispatch ready event for Promise-based waiting
      this.dispatchReadyEvent();
      
      // Show startup notification
      this.showStartupNotification();
      
      // Run post-initialization diagnostics
      this.log('üîç Running post-initialization diagnostics...', 'debug');
      const postDiagnostics = await diagnostics.runDiagnostics();
      this.log(`üìä Final status: ${postDiagnostics.serviceTests.autoStartupService.initialized ? 'Ready' : 'Partial'}`, 'info');
      
      return this.getSystemStatus();
      
    } catch (error) {
      this.log(`üí• Auto-initialization failed: ${error.message}`, 'error');
      console.error('Full error details:', error);
      
      // Export diagnostics on failure
      try {
        const errorDiagnostics = await diagnostics.runDiagnostics();
        console.error('üîç Error diagnostics:', errorDiagnostics);
      } catch (diagError) {
        console.error('Failed to run error diagnostics:', diagError);
      }
      
      this.dispatchErrorEvent(error);
      throw error;
    }
  }

  /**
   * Set global ready state for backwards compatibility
   */
  setGlobalReadyState() {
    // Create the global object that React components expect
    window.iranianLegalArchive = {
      servicesReady: true,
      features: {
        autoScraping: true,
        smartProxy: !!this.services.proxyService,
        advancedSearch: !!this.services.scrapingService,
        dataSync: !!this.services.database
      },
      sessionId: this.getSessionId(),
      isGitHubPages: window.location.hostname.includes('github.io'),
      version: '2.0.0',
      services: this.services,
      getStatus: () => this.getSystemStatus()
    };
    
    this.log('üåê Global iranianLegalArchive object created and ready', 'success');
  }

  /**
   * Dispatch custom event when services are ready
   */
  dispatchReadyEvent() {
    const readyEvent = new CustomEvent('servicesReady', {
      detail: {
        services: this.services,
        status: this.getSystemStatus(),
        timestamp: new Date().toISOString()
      }
    });
    
    window.dispatchEvent(readyEvent);
    this.log('üì° servicesReady event dispatched');
  }

  /**
   * Dispatch error event when initialization fails
   */
  dispatchErrorEvent(error) {
    const errorEvent = new CustomEvent('servicesError', {
      detail: {
        error: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString(),
        logs: this.startupLog.slice(-10)
      }
    });
    
    window.dispatchEvent(errorEvent);
    this.log(`üì° servicesError event dispatched: ${error.message}`);
  }

  /**
   * Get initialization promise for modern async/await usage
   */
  getInitializationPromise() {
    if (this.initializationPromise) {
      return this.initializationPromise;
    }

    this.initializationPromise = new Promise((resolve, reject) => {
      // If already initialized, resolve immediately
      if (this.isInitialized) {
        resolve(this.getSystemStatus());
        return;
      }

      // Listen for ready or error events
      const handleReady = (event) => {
        cleanup();
        resolve(event.detail);
      };

      const handleError = (event) => {
        cleanup();
        reject(new Error(event.detail.error));
      };

      const cleanup = () => {
        window.removeEventListener('servicesReady', handleReady);
        window.removeEventListener('servicesError', handleError);
      };

      window.addEventListener('servicesReady', handleReady, { once: true });
      window.addEventListener('servicesError', handleError, { once: true });

      // Timeout fallback (should not be needed with proper implementation)
      setTimeout(() => {
        cleanup();
        this.log('‚ö†Ô∏è Initialization timeout reached');
        reject(new Error('Services initialization timeout'));
      }, 10000);
    });

    return this.initializationPromise;
  }

  /**
   * Initialize Smart Proxy Service
   */
  async initializeProxyService() {
    this.log('üåê Initializing Smart Proxy Service...');
    
    try {
      this.services.proxyService = new SmartProxyService();
      
      // Test proxy health with timeout
      const proxyPromise = this.services.proxyService.discoverProxies();
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Proxy service timeout')), 5000)
      );
      
      const workingProxies = await Promise.race([proxyPromise, timeoutPromise]);
      this.log(`‚úÖ Proxy Service ready: ${workingProxies.length} proxies available`);
      
      return true;
    } catch (error) {
      this.log(`‚ùå Proxy Service failed: ${error.message}`, 'error');
      console.error('Proxy Service initialization error:', error);
      // Don't fail the entire startup for proxy issues
      return false;
    }
  }

  /**
   * Initialize Advanced Scraping Service
   */
  async initializeScrapingService() {
    this.log('üîç Initializing Advanced Scraping Service...');
    
    try {
      this.services.scrapingService = new AdvancedScrapingService();
      
      // Reset stats for new session
      this.services.scrapingService.resetStats();
      this.log('‚úÖ Scraping Service ready');
      
      return true;
    } catch (error) {
      this.log(`‚ùå Scraping Service failed: ${error.message}`, 'error');
      console.error('Scraping Service initialization error:', error);
      // Don't fail the entire startup for scraping issues
      return false;
    }
  }

  /**
   * Setup background tasks
   */
  async setupBackgroundTasks() {
    this.log('‚öôÔ∏è Setting up background tasks...');
    
    try {
      // Auto-discovery of new proxy sources every 30 minutes
      setInterval(async () => {
        if (this.services.proxyService) {
          this.log('üîÑ Auto-discovering new proxies...');
          await this.services.proxyService.discoverProxies();
        }
      }, 30 * 60 * 1000);

      // Auto-save state every 5 minutes
      setInterval(() => {
        this.saveState();
        this.log('üíæ State auto-saved');
      }, 5 * 60 * 1000);

      // Health check every 10 minutes
      setInterval(async () => {
        await this.performHealthCheck();
      }, 10 * 60 * 1000);

      this.log('‚úÖ Background tasks configured');
      return true;
    } catch (error) {
      this.log(`‚ùå Background tasks failed: ${error.message}`);
      return false;
    }
  }

  /**
   * Initialize data persistence
   */
  async initializeDataPersistence() {
    this.log('üíæ Initializing data persistence...');
    
    try {
      // Setup IndexedDB for large data storage
      await this.setupIndexedDB();
      
      // Load previous scraping results
      await this.loadPreviousResults();
      
      this.log('‚úÖ Data persistence ready');
      return true;
    } catch (error) {
      this.log(`‚ùå Data persistence failed: ${error.message}`);
      return false;
    }
  }

  /**
   * Setup IndexedDB for client-side storage
   */
  async setupIndexedDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('IranianLegalArchive', 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.services.database = request.result;
        resolve(request.result);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Create stores
        if (!db.objectStoreNames.contains('documents')) {
          const documentsStore = db.createObjectStore('documents', { keyPath: 'id', autoIncrement: true });
          documentsStore.createIndex('url', 'url', { unique: false });
          documentsStore.createIndex('source', 'source', { unique: false });
          documentsStore.createIndex('category', 'category', { unique: false });
        }
        
        if (!db.objectStoreNames.contains('scrapingResults')) {
          const resultsStore = db.createObjectStore('scrapingResults', { keyPath: 'id', autoIncrement: true });
          resultsStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
        
        if (!db.objectStoreNames.contains('systemLogs')) {
          db.createObjectStore('systemLogs', { keyPath: 'id', autoIncrement: true });
        }
      };
    });
  }

  /**
   * Load previous scraping results
   */
  async loadPreviousResults() {
    if (!this.services.database) return;
    
    try {
      const transaction = this.services.database.transaction(['scrapingResults'], 'readonly');
      const store = transaction.objectStore('scrapingResults');
      const request = store.getAll();
      
      request.onsuccess = () => {
        const results = request.result;
        this.log(`üìÇ Loaded ${results.length} previous scraping results`);
        
        // Make results available to React components
        window.previousScrapingResults = results;
      };
    } catch (error) {
      this.log(`‚ö†Ô∏è Failed to load previous results: ${error.message}`);
    }
  }

  /**
   * Setup auto-update mechanism
   */
  async setupAutoUpdate() {
    this.log('üîÑ Setting up auto-update...');
    
    try {
      // Check for updates every hour
      setInterval(async () => {
        await this.checkForUpdates();
      }, 60 * 60 * 1000);

      // Initial update check
      setTimeout(() => this.checkForUpdates(), 30000); // After 30 seconds
      
      this.log('‚úÖ Auto-update configured');
      return true;
    } catch (error) {
      this.log(`‚ùå Auto-update failed: ${error.message}`);
      return false;
    }
  }

  /**
   * Check for system updates
   */
  async checkForUpdates() {
    try {
      // Check if new version is available
      const response = await fetch('/manifest.json');
      if (response.ok) {
        const manifest = await response.json();
        this.log(`üîç Checked for updates: v${manifest.version || 'unknown'}`);
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Update check failed: ${error.message}`);
    }
  }

  /**
   * Perform system health check
   */
  async performHealthCheck() {
    this.log('üè• Performing health check...');
    
    const health = {
      proxyService: false,
      scrapingService: false,
      database: false,
      backgroundTasks: true
    };

    try {
      // Check proxy service
      if (this.services.proxyService) {
        const stats = this.services.proxyService.getStats();
        health.proxyService = stats.iranianDNSCount > 0;
      }

      // Check scraping service
      if (this.services.scrapingService) {
        const stats = this.services.scrapingService.getStats();
        health.scrapingService = true;
      }

      // Check database
      health.database = !!this.services.database;

      const healthyServices = Object.values(health).filter(Boolean).length;
      this.log(`üíö Health check: ${healthyServices}/4 services healthy`);
      
      return health;
    } catch (error) {
      this.log(`‚ùå Health check failed: ${error.message}`);
      return health;
    }
  }

  /**
   * Show startup notification
   */
  showStartupNotification() {
    // Create a beautiful startup notification
    const notification = document.createElement('div');
    notification.id = 'startup-notification';
    notification.innerHTML = `
      <div style="
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        z-index: 10000;
        font-family: 'Vazirmatn', sans-serif;
        direction: rtl;
        max-width: 350px;
        animation: slideInRight 0.5s ease-out;
      ">
        <div style="display: flex; align-items: center; margin-bottom: 10px;">
          <span style="font-size: 24px; margin-left: 10px;">üèõÔ∏è</span>
          <h3 style="margin: 0; font-size: 16px;">ÿ≥€åÿ≥ÿ™ŸÖ ÿ¢ÿ±ÿ¥€åŸà ÿ≠ŸÇŸàŸÇ€å ÿ¢ŸÖÿßÿØŸá!</h3>
        </div>
        <p style="margin: 5px 0; font-size: 14px; opacity: 0.9;">
          ‚úÖ ÿ™ŸÖÿßŸÖ ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ÿ¥ÿØŸÜÿØ<br>
          üåê ${Object.keys(this.services).length} ÿ≥ÿ±Ÿà€åÿ≥ ŸÅÿπÿßŸÑ<br>
          ‚ö° ÿ≥€åÿ≥ÿ™ŸÖ ÿ¢ŸÖÿßÿØŸá ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≥ÿ™
        </p>
        <button onclick="this.parentElement.parentElement.remove()" style="
          background: rgba(255,255,255,0.2);
          border: none;
          color: white;
          padding: 8px 15px;
          border-radius: 5px;
          cursor: pointer;
          font-size: 12px;
          margin-top: 10px;
        ">ÿ®ÿ≥ÿ™ŸÜ</button>
      </div>
    `;

    // Add animation styles
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideInRight {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
    `;
    document.head.appendChild(style);
    document.body.appendChild(notification);

    // Auto-remove after 10 seconds
    setTimeout(() => {
      const notif = document.getElementById('startup-notification');
      if (notif) {
        notif.style.animation = 'slideInRight 0.5s ease-out reverse';
        setTimeout(() => notif.remove(), 500);
      }
    }, 10000);
  }

  /**
   * Get comprehensive system status
   */
  getSystemStatus() {
    const status = {
      initialized: this.isInitialized,
      services: Object.keys(this.services),
      serviceCount: Object.keys(this.services).length,
      startupTime: this.startupLog.length > 0 ? this.startupLog[0].timestamp : null,
      lastActivity: this.startupLog.length > 0 ? this.startupLog[this.startupLog.length - 1].timestamp : null,
      sessionId: this.getSessionId(),
      logs: this.startupLog.slice(-10) // Last 10 logs
    };

    // Add service-specific status
    if (this.services.proxyService) {
      status.proxyStats = this.services.proxyService.getStats();
    }
    
    if (this.services.scrapingService) {
      status.scrapingStats = this.services.scrapingService.getStats();
    }

    return status;
  }

  /**
   * Start background scraping automatically
   */
  async startBackgroundScraping() {
    if (!this.services.scrapingService) {
      this.log('‚ùå Cannot start background scraping: service not available');
      return;
    }

    this.log('üîÑ Starting background scraping...');
    
    // High-priority Iranian legal sites
    const prioritySites = [
      { name: 'ÿß€åÿ±ÿßŸÜ ⁄©ÿØ', url: 'https://irancode.ir' },
      { name: 'ŸÖÿ±⁄©ÿ≤ Ÿæ⁄òŸàŸáÿ¥‚ÄåŸáÿß€å ŸÖÿ¨ŸÑÿ≥', url: 'https://rc.majlis.ir' },
      { name: 'ÿÆÿ®ÿ±⁄Øÿ≤ÿßÿ±€å ŸÅÿßÿ±ÿ≥', url: 'https://www.farsnews.ir' }
    ];

    try {
      const results = await this.services.scrapingService.batchScrape(prioritySites, {
        concurrency: 1,
        delayBetween: 5000
      });

      this.log(`‚úÖ Background scraping completed: ${results.length} results`);
      
      // Store results in IndexedDB
      await this.storeScrapingResults(results);
      
      // Make results available globally
      window.latestScrapingResults = results;
      
      return results;
    } catch (error) {
      this.log(`‚ùå Background scraping failed: ${error.message}`);
      return [];
    }
  }

  /**
   * Store scraping results in IndexedDB
   */
  async storeScrapingResults(results) {
    if (!this.services.database) return;

    try {
      const transaction = this.services.database.transaction(['scrapingResults'], 'readwrite');
      const store = transaction.objectStore('scrapingResults');
      
      for (const result of results) {
        const record = {
          ...result,
          timestamp: new Date().toISOString(),
          sessionId: this.getSessionId()
        };
        store.add(record);
      }
      
      this.log(`üíæ Stored ${results.length} scraping results`);
    } catch (error) {
      this.log(`‚ùå Failed to store results: ${error.message}`);
    }
  }

  /**
   * Setup automatic data sync
   */
  async setupDataSync() {
    this.log('üîÑ Setting up data synchronization...');
    
    // Sync with backend every 15 minutes
    setInterval(async () => {
      await this.syncWithBackend();
    }, 15 * 60 * 1000);

    // Initial sync after 1 minute
    setTimeout(() => this.syncWithBackend(), 60000);
  }

  /**
   * Sync data with backend
   */
  async syncWithBackend() {
    try {
      this.log('üîÑ Syncing with backend...');
      
      // Try to reach backend API
      const response = await fetch('/api/health');
      if (response.ok) {
        const health = await response.json();
        this.log(`‚úÖ Backend sync successful: ${health.version}`);
        return true;
      } else {
        this.log('‚ö†Ô∏è Backend not available, using client-side mode');
        return false;
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è Backend sync failed: ${error.message}`);
      return false;
    }
  }

  /**
   * Get navigation guidance for returning users
   */
  getNavigationGuidance() {
    const state = this.loadState();
    const isReturningUser = !!state.lastUpdate;
    
    if (isReturningUser) {
      const guidance = {
        isReturningUser: true,
        lastVisit: state.lastUpdate,
        availableFeatures: [
          { name: 'ÿØÿßÿ¥ÿ®Ÿàÿ±ÿØ ÿßÿµŸÑ€å', path: '/dashboard', description: 'ŸÜŸÖÿß€å ⁄©ŸÑ€å ÿ≥€åÿ≥ÿ™ŸÖ' },
          { name: 'ÿßÿ≥⁄©ÿ±Ÿæ€åŸÜ⁄Ø ŸáŸàÿ¥ŸÖŸÜÿØ', path: '/scraping', description: 'ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿ®ÿß Ÿæÿ±Ÿà⁄©ÿ≥€å Ÿæ€åÿ¥ÿ±ŸÅÿ™Ÿá' },
          { name: 'ÿ¨ÿ≥ÿ™ÿ¨Ÿà€å Ÿæ€åÿ¥ÿ±ŸÅÿ™Ÿá', path: '/search', description: 'ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿØÿ± ÿØÿßÿØŸá‚ÄåŸáÿß€å ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿ¥ÿØŸá' },
          { name: 'ÿ™ÿ≠ŸÑ€åŸÑ ŸáŸàÿ¥ŸÖŸÜÿØ', path: '/ai-analysis', description: 'ÿ™ÿ≠ŸÑ€åŸÑ AI ŸÖÿ™ŸàŸÜ ÿ≠ŸÇŸàŸÇ€å' },
          { name: 'ŸÖÿØ€åÿ±€åÿ™ Ÿæÿ±Ÿà⁄©ÿ≥€å', path: '/proxy', description: 'ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿæÿ±Ÿà⁄©ÿ≥€å ŸáŸàÿ¥ŸÖŸÜÿØ' },
          { name: 'ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ≥€åÿ≥ÿ™ŸÖ', path: '/settings', description: 'Ÿæ€å⁄©ÿ±ÿ®ŸÜÿØ€å ⁄©ÿßŸÖŸÑ ÿ≥€åÿ≥ÿ™ŸÖ' }
        ],
        recommendations: this.getRecommendations(state)
      };
      
      this.log(`üëã Welcome back! Last visit: ${state.lastUpdate}`);
      return guidance;
    }
    
    return {
      isReturningUser: false,
      welcomeMessage: 'ÿ®Ÿá ÿ≥€åÿ≥ÿ™ŸÖ ÿ¢ÿ±ÿ¥€åŸà ÿßÿ≥ŸÜÿßÿØ ÿ≠ŸÇŸàŸÇ€å ÿß€åÿ±ÿßŸÜ ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ',
      quickStart: [
        'ÿßÿ≤ ÿØÿßÿ¥ÿ®Ÿàÿ±ÿØ ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ',
        'ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿæÿ±Ÿà⁄©ÿ≥€å ÿ±ÿß ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜ€åÿØ', 
        'ÿßÿ≥⁄©ÿ±Ÿæ€åŸÜ⁄Ø ŸáŸàÿ¥ŸÖŸÜÿØ ÿ±ÿß ÿßŸÖÿ™ÿ≠ÿßŸÜ ⁄©ŸÜ€åÿØ'
      ]
    };
  }

  /**
   * Get personalized recommendations
   */
  getRecommendations(state) {
    const recommendations = [];
    
    if (state.services && state.services.includes('scrapingService')) {
      recommendations.push({
        title: 'ÿßÿØÿßŸÖŸá ÿßÿ≥⁄©ÿ±Ÿæ€åŸÜ⁄Ø',
        description: 'ÿßÿ≥⁄©ÿ±Ÿæ€åŸÜ⁄Ø ŸÇÿ®ŸÑ€å ÿ¥ŸÖÿß ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ÿØŸá ÿßÿ≥ÿ™',
        action: 'ÿ®Ÿá ÿµŸÅÿ≠Ÿá ÿßÿ≥⁄©ÿ±Ÿæ€åŸÜ⁄Ø ÿ®ÿ±Ÿà€åÿØ',
        path: '/scraping'
      });
    }
    
    recommendations.push({
      title: 'ÿ®ÿ±ÿ±ÿ≥€å ŸÜÿ™ÿß€åÿ¨ ÿ¨ÿØ€åÿØ',
      description: 'ŸÜÿ™ÿß€åÿ¨ ÿßÿ≥⁄©ÿ±Ÿæ€åŸÜ⁄Ø ÿÆŸàÿØ⁄©ÿßÿ± ÿ¢ŸÖÿßÿØŸá ÿßÿ≥ÿ™',
      action: 'ŸÖÿ¥ÿßŸáÿØŸá ÿØÿßÿ¥ÿ®Ÿàÿ±ÿØ',
      path: '/dashboard'
    });
    
    return recommendations;
  }

  /**
   * Export system state for debugging
   */
  exportSystemState() {
    const state = {
      ...this.getSystemStatus(),
      fullLogs: this.startupLog,
      localStorage: this.loadState(),
      timestamp: new Date().toISOString()
    };
    
    const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `system_state_${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    this.log('üì§ System state exported');
  }

  /**
   * Reset system to clean state
   */
  resetSystem() {
    localStorage.removeItem(this.persistenceKey);
    sessionStorage.clear();
    
    // Clear IndexedDB
    if (this.services.database) {
      this.services.database.close();
      indexedDB.deleteDatabase('IranianLegalArchive');
    }
    
    this.log('üîÑ System reset completed');
    window.location.reload();
  }

  /**
   * Export comprehensive diagnostics for debugging
   */
  async exportDiagnostics() {
    try {
      this.log('üìä Exporting comprehensive diagnostics...', 'debug');
      
      const fullDiagnostics = {
        autoStartupService: {
          status: this.getSystemStatus(),
          logs: this.startupLog,
          services: this.services,
          isInitialized: this.isInitialized
        },
        systemDiagnostics: await diagnostics.runDiagnostics(),
        exportTime: new Date().toISOString()
      };
      
      const blob = new Blob([JSON.stringify(fullDiagnostics, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `startup_diagnostics_${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      this.log('üì§ Diagnostics exported successfully', 'success');
      return fullDiagnostics;
    } catch (error) {
      this.log(`‚ùå Failed to export diagnostics: ${error.message}`, 'error');
      throw error;
    }
  }
}

// Global instance
const autoStartup = new AutoStartupService();

// Enhanced startup with Promise-based API
const initializeServices = async () => {
  try {
    console.log('üöÄ Starting Iranian Legal Archive initialization...');
    await autoStartup.autoInitialize();
    console.log('‚úÖ All services initialized successfully');
  } catch (error) {
    console.error('‚ùå Critical initialization failure:', error);
    // Even on failure, make service available for debugging
    autoStartup.setGlobalReadyState();
  }
};

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeServices);
} else {
  // DOM already loaded
  initializeServices();
}

// Make available globally for React components
window.autoStartupService = autoStartup;

// Global debugging helpers
window.debugStartup = {
  exportDiagnostics: () => autoStartup.exportDiagnostics(),
  getSystemStatus: () => autoStartup.getSystemStatus(),
  getInitializationPromise: () => autoStartup.getInitializationPromise(),
  resetSystem: () => autoStartup.resetSystem(),
  runDiagnostics: () => diagnostics.runDiagnostics(),
  logs: () => autoStartup.startupLog,
  services: () => autoStartup.services
};

console.log('üõ†Ô∏è Debug helpers available: window.debugStartup');
console.log('   - exportDiagnostics(): Export full diagnostic report');
console.log('   - getSystemStatus(): Get current system status');
console.log('   - resetSystem(): Reset and reload system');
console.log('   - runDiagnostics(): Run system diagnostics');
console.log('   - logs(): View startup logs');
console.log('   - services(): View loaded services');

// Export both the service instance and the initialization promise
export default autoStartup;
export { initializeServices };